/*
 * (c) Copyright 2015 Tigran Avanesov, SnT, University of Luxembourg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* 
 * Goal: extract bidirectional flows from nfcapd files. 
 * if host A start a communication to host B, 
 * two flows can be found in netflow database A->B and B->A;
 * we want to consider them as one A->B.
 *
 * nfdump can do it, but it needs to reed all flows to memory which is not acceptable
 *
 * We will monitor the "backward" flows to merge with the forward one 
 * within a time interval, defined in 
 * TIME_WINDOW constant (in ms)
 * 
 * This module reads from stdin 
 * values generated by nfdump with the follwoing format: 
 *     nfdump -q  -N  -R nfcapd.201112050002:nfcapd.201112052357  -o "fmt:%ts %sa %sp %da %dp %byt"
 * Nfdump output example:
 *     2011-12-05 00:04:16.223   177.233.227.36  63057   107.242.93.192   6969      100
 *     2011-12-05 00:04:47.839   171.55.226.123     80  128.238.221.202  53653       46
 *
 * The tool outputs the flows in format (start-time sourceip destinationip)
 *
 * epochtime srcip dstip
 *
 * e.g.
 * 1413084299637 24.69.69.136 192.168.1.131
 * 1413084492160 192.168.1.131 193.175.86.30
 *
 */
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/member.hpp>
#include <algorithm>
#include <iostream>
#include <iterator>
#include <string>

#include <time.h>

using namespace std;
using boost::multi_index_container;
using namespace boost::multi_index;

// a time window in which the backward flows
#define TIME_WINDOW 120000


// A single flow entry, 
// starttime, "srcip|srcport>dstip|dstport", fsize
class Flow
{
	public:
		size_t         starttime; 
		std::string 	srcdest; //"srcip|srcport>dstip|dstport"  ; yes, could be another structure, but neet to cope with ipv6 vs ipv4
		int	fsize;  // flow size, if we need it

		Flow(size_t starttime,	 const std::string& srcdest,  int fsize):
			starttime(starttime),	srcdest(srcdest), fsize(fsize){}
		Flow(size_t starttime, const std::string& src_ip, int src_port, const std::string& dest_ip, int dest_port, int fsize): starttime(starttime), fsize(fsize){
			srcdest = src_ip + "|"  + std::to_string(src_port) + ">" +dest_ip +  "|"  + std::to_string(dest_port);
		};
		string get_reverse() const{
			int pos = srcdest.find('>');
			return srcdest.substr(pos+1) + ">" + srcdest.substr(0, pos) ;
		}
	 	void incsize(int newbytes){
			fsize += newbytes;
		}
		string get_src_dest(const string& separator) const{
			int pos = srcdest.find('|');  // where src port starts and src ip ends
			int pos1 = srcdest.find('>');  // between src and dest; where dest ip starts
			int pos2 = srcdest.rfind('|');  // where dest ip ends
			return srcdest.substr(0, pos) + separator + srcdest.substr(pos1+1, pos2-pos1-1);
		}

		friend std::ostream& operator<<(std::ostream& os,const Flow& f)
		{
			os<<f.starttime<<" "<<f.srcdest << " "<< f.fsize << " " <<std::endl;
			return os;
		}

};


/* tags for accessing the corresponding indices of flowset */

struct starttime{};
struct srcdest{};

// define a multiply indexed set with indices by id and name
typedef multi_index_container<
	Flow, 
	indexed_by<
	// sort by flow::operator<
		ordered_non_unique<
			tag<starttime>, BOOST_MULTI_INDEX_MEMBER(Flow, size_t, starttime) 
		>,

	// sort by less<string> on name
		ordered_non_unique<
			tag<srcdest>, BOOST_MULTI_INDEX_MEMBER(Flow, std::string, srcdest) 
		//  equiv. to:  	member<Flow,std::string,&Flow::srcdest> 
		>
	> 
> flowset;


class FlowContainer: public flowset{
	private:
		size_t m_interval = 0; // interval of time in ?? for buffering flows
	public:
		template<typename Tag>
			void print_out_by(
					Tag* =0 
					)
			{
				/* obtain a reference to the index tagged by Tag */

				const typename boost::multi_index::index<FlowContainer,Tag>::type& i=
					boost::multi_index::get<Tag>(*this);
				// auto i= get<Tag>(*this); //does not work

				typedef typename FlowContainer::value_type value_type;

				/* dump the elements of the index to cout */
				std::copy(i.begin(),i.end(),std::ostream_iterator<value_type>(std::cout));
			};
		void setup( size_t time_interval ){
			m_interval = time_interval;
		};
		void insert_and_check(
				size_t time, 
				string& src_ip, 
				int src_port, 
				string& dest_ip, 
				int dest_port,
				int bytez){
			Flow f(time, src_ip, src_port, dest_ip, dest_port, bytez);
			string backw = f.get_reverse();

			// find the corresponding flow
			auto iflow = this->get<srcdest>().find(backw);
			if (iflow != this->get<srcdest>().end()){
				while ((iflow != this->get<srcdest>().end()) && (backw.compare( iflow->srcdest)==0)){
					// process it
					process(*iflow, bytez); 
					// does not work iflow->incsize(bytez); 
					bytez=0;
					// remove all of them...
					iflow = this->get<srcdest>().erase(iflow);
				}
			} else {
				// add the flow
				this->insert(f);
			}
			
			// process and remove outdated flows
			////may be optimized? store max value and compare to the new one
			size_t mintime = this->get_min_acceptable_time();
			auto ifl = this->get<starttime>().begin();
			while ((ifl != this->get<starttime>().end()) && (ifl->starttime < mintime)){
				process(*ifl, 0);
				ifl = this->get<starttime>().erase(ifl);
			}

		};
		void flush(){
			// process all remaining flows and removes them:
			auto ifl = this->get<starttime>().begin();
			while (ifl != this->get<starttime>().end()){
				process(*ifl, 0);
				ifl = this->get<starttime>().erase(ifl);
			}
		}
		void process(const Flow &f, int newbytes){
			cout << f.starttime<<" "<<f.get_src_dest(string(" "))<< std::endl;
		};

		void process_debug(const Flow &f, int newbytes){
			cout << "processed "; // debug
			// doest not work, because of const:  f.incsize(newbytes);
			cout << f.starttime<<" "<<f.srcdest << " "<< f.fsize +newbytes << " | size added " << newbytes <<std::endl;
			//cout << f << " size.added " << newbytes << endl;
		};
		size_t get_max_time(){
			auto end = this->get<starttime>().end();
			if (end != this->get<starttime>().begin()){ // if the set of flows is not empty 
			       	end--;
				return end->starttime;
			} else {
				return 0;
			}
		}
		size_t get_min_time(){
			return this->get<starttime>().begin()->starttime;
		}
		size_t get_min_acceptable_time(){
			auto mxtime = this->get_max_time();
			if (mxtime != 0)
				return this->get_max_time() - m_interval;
			else 
				return 0;
		}
};


void tests(){
	FlowContainer fs;

	fs.insert(Flow(0.00,"A|5>C|7",0));
	fs.insert(Flow(2.00,"A|6>C|8",0));
	fs.insert(Flow(1.0,"B|3>C|4",0));
	fs.insert(Flow(2.0,"B|3>C|4",0));
	fs.insert(Flow(1.0,"A|2>E|11",0));
	fs.insert(Flow(2.0,"A|2>F|134",0));
	fs.insert(Flow(2.4,"F|22>A|11",0));
	fs.insert(Flow(1.0,"D|99>E|123323",0));
	fs.insert(Flow(1.0,"e|3>B|3",1));


	fs.print_out_by<starttime>();

	/* //getting last, maximal element
	   cout << "++++";
	   auto z = fs.get<srcdest>().end();
	   z--;
	   cout << *z;
	   */

	cout << "----- by srcdest ---- " << endl;

	fs.print_out_by<srcdest>();

	/*
	   cout << " Enter time (size_t) : ";
	   size_t t;
	   cin >> t;
	   flowset::index<starttime>::type::iterator  found = fs.get<starttime>().find(t);

	   while ((found != fs.get<starttime>().end()) && (found->starttime==t)){
	   cout << "Found " << *found;
	   found++;
	   }
	   */


	fs.setup(3.0);
	while (true) {
		cout << " Enter flow (str) starttime, srcip, srcport, destip destport : ";
		string sip;
		string dip;
		int sport;
		int dport;
		size_t st;
		cin >> st;
		cin >> sip;
		cin >> sport;
		cin >> dip;
		cin >> dport;

		fs.insert_and_check(st, sip, sport, dip, dport, 0);
		fs.print_out_by<starttime>();
	}
	/*
	   auto founds = fs.get<srcdest>().find(s);
	//	flowset::index<srcdest>::type::iterator  founds = fs.get<srcdest>().find(s);

	while (founds != fs.get<srcdest>().end()){
	cout << *founds;
	founds++;
	}

	cout << "Removing 1st starttime" << endl;
	found = fs.get<starttime>().find(t);
	if (found != fs.get<starttime>().end())
	fs.erase(found);

	fs.print_out_by<starttime>();

	cout << "Removing 1st srcdest" << endl;
	founds = fs.get<srcdest>().find(s);
	if (founds != fs.get<srcdest>().end())
	fs.get<srcdest>().erase(founds);
	fs.insert(Flow(-1.0,"A", 34, "BBB", 123 ,1));
	*/

}


size_t datetime_string_to_milliseconds(const string &sdate, const string &stime){
	//string sdate="2011-12-05";
        //string stime= "00:04:16.223";

	//dummy way, non-locale-proof!  but did not find library (TODO)
	size_t pos = sdate.find("-");
	int year = stoi(sdate.substr(0,pos++));
	size_t pos1 = sdate.find("-", pos);
	int month = stoi(sdate.substr(pos,pos1++));
	int day = stoi(sdate.substr(pos1));

	pos = stime.find(":");
	int hour = stoi(stime.substr(0,pos++));
	pos1 = stime.find(":", pos);
	int minutes =  stoi(stime.substr(pos,pos1++));
	int milliseconds = int(1000*stof(stime.substr(pos1++)));
	

	/*
	cout << year << endl; 
	cout << month << endl; 
	cout << day << endl; 
	cout << hour << endl; 
	cout << minutes << endl; 
	cout << milliseconds << endl; 
	*/
	
	struct tm t;
	time_t res;
	t.tm_year = year-1900;
	t.tm_mon = month-1;           // Month, 0 - jan
	t.tm_mday = day;          // Day of the month
	t.tm_hour = hour;     
	t.tm_min = minutes;
	t.tm_sec = milliseconds / 1000;
	t.tm_isdst = -1;        // Is DST on? 1 = yes, 0 = no, -1 = unknown
	res = timegm(&t);
	// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_14
	return res*1000+ milliseconds % 1000;
}

Flow nfdump_string_to_flow(const string &sdate, const string &stime, const string& srcip, int srcport, const string& destip, int destport, int bytez){
	// will read output from 
	// nfdump -q  -N  -R nfcapd.201112050002:nfcapd.201112052357  -o "fmt:%ts %sa %sp %da %dp %byt"
	// e.g.
	// 2011-12-05 00:04:16.223   177.233.227.36  63057   107.242.93.192   6969      100
	// 2011-12-05 00:04:47.839   171.55.226.123     80  128.238.221.202  53653       46
	// 2011-12-05 00:04:30.495    107.242.86.82  30284  173.239.176.201  16064     1944
	// start date-time            src ip         srcport	dst ip       dstport  bytes
	Flow f(datetime_string_to_milliseconds(sdate, stime), srcip, srcport, destip, destport, bytez);
	return f;
}

int main(){
	//tests();
	//cout << datetime_string_to_milliseconds("2011-12-05", "00:04:16.223") << endl;
	
	FlowContainer fs;
	fs.setup(TIME_WINDOW); //in ms, example, 2min of window 


	string sdate, stime, srcip, destip;
	int srcport;
	long  bytez;  // long, because got size 2331441824 from port 0 to port 0...
	float destport; // can be float! e.g. 11.1 as in    "fmt:%ts %sa %sp %da %dp %byt"  2011-12-05 00:04:16.226    107.242.91.50      0   177.228.219.35   1.11    12672

	// will read output from 
	// nfdump -q  -N  -R nfcapd.201112050002:nfcapd.201112052357  -o "fmt:%ts %sa %sp %da %dp %byt"
	// e.g.
	// 2011-12-05 00:04:16.223   177.233.227.36  63057   107.242.93.192   6969      100
	// 2011-12-05 00:04:47.839   171.55.226.123     80  128.238.221.202  53653       46
	// 2011-12-05 00:04:30.495    107.242.86.82  30284  173.239.176.201  16064     1944
	// start date-time            src ip         srcport	dst ip       dstport  bytes
	while (cin >> sdate >> stime >> srcip >>srcport >> destip >> destport >> bytez){
		//cout <<sdate << " " << stime << " " << srcip << " " <<  srcport << " " << destip << " " << destport << " " << bytez << std::endl;
		fs.insert_and_check(datetime_string_to_milliseconds(sdate, stime), srcip, srcport, destip, int(destport), bytez);
	}

	fs.flush();

	//std::cout << typeid( fs.get<starttime>().find(t)).name();
	return 0;
}

